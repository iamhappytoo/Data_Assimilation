function MOD_WET_wrapper_truegen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Written by Steve Margulis, May 5, 2017
%
% This is a "wrapper" script that generates a MOD-WET model realization and
% set of measurements to be used as the true states and measurements in a
% synthetic experiment (or Observing System Simulation Experiment). The 
% code is setup to be adapted to include various uncertainties in initial 
% conditions, time-invariant parameters, and meteorological forcings. 
%
% For tractability, the current setup uses lognormal multiplicative 
% perturbations as a way of adding uncertainty to model inputs. 
% Modifications could be made to include additive errors of varying form.
% The initial condition and parameters uncertainty is introduced in the 
% form of spatially-correlated fields (that can be cross-correlated) using
% the TBCOSIM function (tbcosim_uncond_func.m) that has been adapted for 
% simulation of random 
%
% Calling of MOD-WET (including re-starts with updated states) is handled
% entirely through modification of its input structure array: restart_info.
% It is assumed that MOD-WET is already setup for a nominal watershed with
% a nominal set of parameters and forcings. Those nominal inputs are first 
% loaded, then perturbations are generated and those inputs that are 
% changed are saved to the restart_info array for initial conditions and 
% parameters and to meteorological forcing input files. The true states and
% measurements are generated by perturbing the initial conditions,
% parameters, and/or forcing inputs.
%
% The perturbations are based on uncertainty parameters specified in the
% file: 
% model_input_uncertainty_parameters.m
%
% The measurement must be defined by defining the state vector and the
% measurement model through a separate function: 
% measurement_model.m.
% 
% The default setup runs a case where rootzone soil moisture Srz and
% saturation deficit (SD) are included the state vector to be updated and
% the measurements are the spatially-distributed map of Srz once every
% three days. The independent measurement error is specified in the 
% variable Cv.
%
% Outputs for the true states and measurements are saved respectively in
% the output files:
% true_output.mat
% measurements.mat
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear all;close all
%% Specify path to MOD-WET functions
% Specify  to root directory for the MOD-WET functions
toolbox_path='C:/Users/BANZH/Downloads/2019spring/CEE steve/MOD_WET_2017a/MOD_WET_2017a/MOD_WET_src';
% Add path
addpath(genpath(toolbox_path))

%% --------- SPECIFY INPUTS HERE ----------------------------------------%%
% Note: Additional inputs are specified in: model_input_uncertainty_parameters.m 
% and in the measurement model: measurement_model.m

% Specify whether to invoke some plots (set to 0 to skip plotting below
% or to 1 to perform plotting)
plot_flag=0;

% Set period over which to run MOD-WET
start_day=1;
n_days=243;

% Number of ensemble members to run (set to 1 if running the true simulation)
N_ensemble_members=1; % generate truth

% Set random seeds for model input uncertainties (allows control so that
% the true is repeatable)
rng('default');
seed1=1000;
seed2=1001;

% Specify root directory where to store outputs
output_root_dir='C:/Users/BANZH/Downloads/2019spring/CEE Steve/Project_outputs/long_true_output_weekly_0.1/';
mkdir(output_root_dir);
%% Measurements and measurement info.
% Note: Measurement model is defined separately in a "measurement_model.m"
% function. Relationship between states and measurements also related to
% the uncertain_states defined below and the pre-allocation of Y_ENS and
% Z_MEAS.
% Specify measurement times in days from start of simulation (at end of each day)
meas_day_vector=[1:7:n_days-1];
% Specify measurement error variance
Cv=(0.1)^2;

%% Define MOD-WET states
% These are all of the states that MOD-WET propagates and not necessarily
% all of those that will be updated via DA.
mod_wet_states(1).names='Srz';mod_wet_states(2).names='Suz';
mod_wet_states(3).names='SD';mod_wet_states(4).names='Tsurf';
mod_wet_states(5).names='SWE';mod_wet_states(6).names='snowdepth';
mod_wet_states(7).names='snowfrac';mod_wet_states(8).names='snowdens';
mod_wet_states(9).names='Td';
mod_wet_states(10).names='NDayLastSnow';

%% Define uncertain model inputs. Uncertainty parameters are specified in the function: model_input_uncertainty_parameters.m
% This is the subset of states that are treated as uncertain and that will
% be updated via the DA, e.g.:
% Updating of Srz and SD only:
uncertain_state_numbers=[3]; % here Srz and SD from list above.
% Updating SWE only:
%uncertain_state_numbers=[5]; % here SWE from list above.

% Store names of states being treated as uncertain/updated
for ii=1:length(uncertain_state_numbers)
    uncertain_states(ii).names=mod_wet_states((uncertain_state_numbers(ii))).names;
end

% Define uncertain time-invariant parameters by name:
% These are not updated, but add uncertainty to the states via the model
% physics
uncertain_params(1).names='T0';
uncertain_params(2).names='K0'; % these two parameters are really coupled, but can control this by making them perfectly correlated below
%
% Define uncertain time-varying forcing by name:
% Meteorological inputs that are treated as uncertain. Note: As currently
% constructed MOD-WET takes in only a single set of forcings and then
% distributes the forcing spatially within the model. This makes it
% difficult to treat these inputs as random spatial fields. So instead they
% are just treated as correlated single perturbations that can vary in
% time, but are deterministically distributed in space according to the 
% MOD-WET disaggregation equations.
uncertain_forcings(1).names='PPT';
tsSD=nan(1,5833);
tsET=nan(1,5832);
tsQ=nan(1,5832);
tsSrz=nan(1,5833);
mapSD=nan(26,19,5832,1);
mapET=nan(26,19,5832,1);
mapSrz=nan(26,19,5832,1);
%% --------- END OF INPUT SPECIFICATION ---------------------------------%%

%% Call initialization codes to get nominal parameters for model simulation. 
% This first part is just a simple mechanism to load the nominal 
% parameters/initial from the existing MOD-WET parameter/initial condition 
% functions. The desired variable values should be set in those functions 
% and are loaded here. By running these functions, all of the parameters 
% are stored in the "restart_info" structure array. The nominal values can 
% then be perturbed and replaced as inputs.  
%
% Load nominal control parameters (i.e. start day, time step, number of 
% days, etc.)
[restart_info.control_params]=set_control_parameters;
% This is to make sure hourly maps are output (assumes forcing is provided
% at 0.25 hour interval)
restart_info.control_params.map_frq2store=4;
%
% Load nominal static physical parameters (soil parameters, TOPMODEL 
% parameters, etc. that are defined in the standard MOD-WET input
% functions.
[restart_info.params]=set_static_physical_parameters(restart_info.control_params);
%
% pre-allocation of variables
[restart_info.states,~,~,~]= ...
                pre_allocate_variables(restart_info.control_params,restart_info.params);
%
% Load nominal initial conditions for state variables (i.e. "old_vars")
[~,~,restart_info.old_vars]= ...
        initialize_model(restart_info.control_params,restart_info.params,restart_info.states);


%% Grab domain-specific parameters
% Grab mask of pixel indices (the length of this vector is the size of 
% the state vector per variable.
pixel_indices=find(restart_info.params.static_maps.mask==1);
Npix=length(pixel_indices);

%% Pre-allocate state vector
Y_ENS=NaN(Npix*length(uncertain_states),N_ensemble_members);
% Pre-allocate predicted measurement vector (this will depend on what the 
% measurements are being assimilated).
Z_ENS=NaN(Npix,N_ensemble_members);

%% Set simulation control parameters:
% This might be useful for calling the model for different time
% periods (i.e. when using a filter). These are just copied from the
% set_control_parameters.m.
% Replace the starting day of the simulation (0 is the beg. of the WY)
restart_info.control_params.start_day=start_day; % start simulation
% Replace the length of the simulation and related input parameters.
restart_info.control_params.n_days=n_days; % number of days to simulate
restart_info.control_params.ntime=1./restart_info.control_params.dt*24.*restart_info.control_params.n_days;
% Length of time series to store (needs to be an integer)
restart_info.control_params.nt=restart_info.control_params.ntime/restart_info.control_params.timeseries_frq2store; 
% Set index to initialize forcings 
restart_info.control_params.start_time=1+...     
    restart_info.control_params.start_day*24./restart_info.control_params.dt;

%% Loop through an ensemble of simulations (with different inputs)        
for i_ensemble=1:N_ensemble_members

    % Replace output filename with one specific to this ensemble member
    restart_info.control_params.output_filename=[output_root_dir 'true_output.mat'];

    %% Perturb. uncertain inputs:
    % load nominal forcings
    eval(['load ' '''' restart_info.control_params.met_data_filename ''''])

    %% Call function that generates perturbations based on specified statistics
    [IC_perturbations,params_perturbations,forcing_perturbations]=...    
    model_input_uncertainty_parameters(uncertain_states,uncertain_params,...
    uncertain_forcings,restart_info,length(PPT),seed1,seed2);

    % ---- Perturb initial conditions (based on statistics above):    
    % Loop through states that will be perturbed
    for ii=1:length(uncertain_states)
        if (plot_flag==1)
            figure;
            subplot(1,3,1);eval(['imagesc(restart_info.old_vars.' uncertain_states(ii).names '0)']);axis image;
            colorbar;title(['Nominal ' uncertain_states(ii).names])
            subplot(1,3,2);imagesc(IC_perturbations(:,:,ii));axis image; 
            colorbar;title(['Perturbation for ' uncertain_states(ii).names])
            subplot(1,3,3);eval(['imagesc(IC_perturbations(:,:,ii).* restart_info.old_vars.' uncertain_states(ii).names '0)'])
            axis image; colorbar;title(['Perturbed ' uncertain_states(ii).names])
            pause
        end
        command=['restart_info.old_vars.' uncertain_states(ii).names '0 = IC_perturbations(:,:,ii).* restart_info.old_vars.' uncertain_states(ii).names '0;'];
        eval(command)
    end
    
    %% NEW CODE !!
            % Make sure any updated states are within defined (physical)
            % bounds
            % Srz (needs to be within min-max range)
            I=find(restart_info.old_vars.Srz0<restart_info.params.static_maps.Srzmin);
            restart_info.old_vars.Srz0(I)=restart_info.params.static_maps.Srzmin(I);
            I=find(restart_info.old_vars.Srz0>restart_info.params.static_maps.Srzmax);
            restart_info.old_vars.Srz0(I)=restart_info.params.static_maps.Srzmax(I);
            % SD (should be non-negative)
            I=find(restart_info.old_vars.SD0<0);
            restart_info.old_vars.SD0(I)=0;
            % Set Suz0 to zero where SD0 is zero
            restart_info.old_vars.Suz0(I)=0;
            % SWE and other snow states (should be non-negative)
            I=find(restart_info.old_vars.SWE0<0);
            restart_info.old_vars.SWE0(I)=0;
            restart_info.old_vars.snowdens0(I)=0;
            restart_info.old_vars.snowdepth0(I)=0;
            restart_info.old_vars.snowfrac0(I)=0;
            % Make sure temperature in snow-covered areas is less than or
            % equal to freezing
            I=find(restart_info.old_vars.SWE0>0 & restart_info.old_vars.Tsurf0>273.15);
            restart_info.old_vars.Tsurf0(I)=273.15;
            %% END NEW CODE !!
    
    % ---- Perturb time-invariant parameters (based on statistics above):
    % Loop through parameters that will be perturbed
    for ii=1:length(uncertain_params)
        if (plot_flag==1)
            figure;
            subplot(1,3,1);eval(['imagesc(restart_info.params.static_maps.' uncertain_params(ii).names ')']);axis image;
            colorbar;title(['Nominal ' uncertain_params(ii).names])
            subplot(1,3,2);imagesc(IC_perturbations(:,:,ii));axis image; 
            colorbar;title(['Perturbation for ' uncertain_params(ii).names])
            subplot(1,3,3);eval(['imagesc(params_perturbations(:,:,ii).*restart_info.params.static_maps.' uncertain_params(ii).names ')'])
            axis image; colorbar;title(['Perturbed ' uncertain_params(ii).names])
            pause
        end
        command=['restart_info.params.static_maps.' uncertain_params(ii).names ' = params_perturbations(:,:,ii).* restart_info.params.static_maps.' uncertain_params(ii).names ';'];
        eval(command)
    end
    %% NEW CODE !! 
            % save parameters (within restart_info structure array) to file
            % for later use
            restart_params_filename=[output_root_dir 'ensemble_member_' num2str(i_ensemble) '_perturbed_params.mat'];
            perturbed_params=restart_info.params;
            eval(['save ' '''' restart_params_filename '''' ' perturbed_params'])
    %% END NEW CODE !!
    %
    % ---- Perturb time-varying forcings (based on statistics above):
    % Loop through forcings and apply perturbations
    for ii=1:length(uncertain_forcings)
        if (plot_flag==1)
            figure;
            subplot(3,1,1)
            eval(['plot(' uncertain_forcings(ii).names ')']);
            ylabel(uncertain_forcings(ii).names);axis tight;grid
            subplot(3,1,2)
            eval(['plot(forcing_perturbations(ii,:))']);
            ylabel('Perturb.');axis tight;grid
            subplot(3,1,3)
            eval(['plot(' uncertain_forcings(ii).names '.*forcing_perturbations(ii,:))']);
            ylabel(['Perturb. ' uncertain_forcings(ii).names]);axis tight;grid
            pause
        end
        command=[uncertain_forcings(ii).names ' = ' uncertain_forcings(ii).names '.* forcing_perturbations(ii,:);' ];
        eval(command)
    end

    % Write forcings to file that will be loaded by MOD-WET
    restart_info.control_params.met_data_filename=[output_root_dir 'true_met_forcing_input.mat'];
    eval(['save ' '''' restart_info.control_params.met_data_filename '''' ' time gage_elev PPT SW Ta qa U Psfc'])


    %% Call MOD-WET with perturbed inputs
    MOD_WET_model_driver(restart_info)
    %% Load outputs and plot some states/fluxes
    eval(['load ' '''' restart_info.control_params.output_filename ''''])
    tsSD(i_ensemble,:)=states.time_series.SD;
    tsET(i_ensemble,:)=fluxes.time_series.ET;
    tsQ(i_ensemble,:)=fluxes.time_series.outlet_hydrograph;
    tsSrz(i_ensemble,:)=states.time_series.Srz;
    mapSD(:,:,:,i_ensemble)=states.maps.SD;
    mapET(:,:,:,i_ensemble)=fluxes.maps.ET;
    mapSrz(:,:,:,i_ensemble)=states.maps.Srz;
end
%% end ensemble loop

%% Load MOD-WET model outputs
eval(['load ' '''' restart_info.control_params.output_filename ''''])

%% Generate measurements (this will depend on the measurements being used)
for imeas=1:length(meas_day_vector)
    Y=NaN(Npix,length(uncertain_states));
    for ii=1:length(uncertain_states)
        meas_index=meas_day_vector(imeas)*24*...
            restart_info.control_params.map_frq2store*...
            restart_info.control_params.dt;
        command=['tmp=states.maps.' uncertain_states(ii).names '(:,:,meas_index);'];
        eval(command)
        command=['Y(:,ii)=tmp(pixel_indices);'];
        eval(command)
    end
    Z=measurement_model(Y);
    CV=diag(Cv*ones(size(Z,1),1));
    v=mvnrnd(zeros(1,size(Z,1)),CV)';
    ZMEAS(:,imeas)=measurement_model(Y)+v;
end

% Since all states are non-negative, limit synthetic meas. to non-negative
% values (in case where measurement error makes negative)
ZMEAS(ZMEAS<0)=0;
    
%% Save measurements
filename=[output_root_dir 'measurements.mat'];
eval(['save ' '''' filename '''' ' meas_day_vector ZMEAS Cv start_day n_days restart_info'])    

%% load open loop ensemble outputs
oltsQ=load('C:/Users/BANZH/Downloads/2019spring/CEE steve/Project_outputs/open_loop_ensemble1year/tsQ.mat','tsQ');
oltsET=load('C:/Users/BANZH/Downloads/2019spring/CEE steve/Project_outputs/open_loop_ensemble1year/tsET.mat','tsET');
oltsSD=load('C:/Users/BANZH/Downloads/2019spring/CEE steve/Project_outputs/open_loop_ensemble1year/tsSD.mat','tsSD');
oltsSrz=load('C:/Users/BANZH/Downloads/2019spring/CEE steve/Project_outputs/open_loop_ensemble1year/tsSrz.mat','tsSrz');
olmapET=load('C:/Users/BANZH/Downloads/2019spring/CEE steve/Project_outputs/open_loop_ensemble1year/mapET.mat','mapET');
olmapSD=load('C:/Users/BANZH/Downloads/2019spring/CEE steve/Project_outputs/open_loop_ensemble1year/mapSD.mat','mapSD');
olmapSrz=load('C:/Users/BANZH/Downloads/2019spring/CEE steve/Project_outputs/open_loop_ensemble1year/mapSrz.mat','mapSrz');

%% Plot truth realization together with open loop ensembles of realizations
DOY=1:1:243;
figure(1);hold on
plot(DOY,mean(reshape(states.time_series.SD(2:5833),24,243)),'k','LineWidth',3)
for i=1:20
    figure(1);hold on
    plot(DOY,mean(reshape(squeeze(oltsSD.tsSD(i,2:5833)),24,243)),'c');
end
        xlabel('DOWY');ylabel('SD (m)')
        set(gca,'FontSize',18,'YDir','normal');grid;
        legend('Truth','Ensemble','Location','south')
figure(2);hold on
plot(DOY,mean(reshape(states.time_series.Srz(2:5833),24,243)),'k','LineWidth',3)
for i=1:20
    figure(2);hold on
    plot(DOY,mean(reshape(squeeze(oltsSrz.tsSrz(i,2:5833)),24,243)),'c');
end
        xlabel('DOWY');ylabel('Srz (m)')
        set(gca,'FontSize',18,'YDir','normal');grid;
        legend('Truth','Ensemble','Location','south')     

figure(3);hold on
plot(DOY,mean(reshape(fluxes.time_series.ET,24,243)),'k','LineWidth',3)
for i=1:20
    figure(3);hold on
    plot(DOY,mean(reshape(squeeze(oltsET.tsET(i,:)),24,243)),'c');
end
        xlabel('DOWY');ylabel('ET (m/h)')
        set(gca,'FontSize',18,'YDir','normal');grid;
        legend('Truth','Ensemble','Location','south')     

figure(4);hold on
plot(DOY,mean(reshape(fluxes.time_series.outlet_hydrograph,24,243)),'k','LineWidth',3)
for i=1:20
    figure(4);hold on
    plot(DOY,mean(reshape(squeeze(oltsQ.tsQ(i,:)),24,243)),'c');
end
        xlabel('DOWY');ylabel('Q (m^3/s)')
        set(gca,'FontSize',18,'YDir','normal');grid;
        legend('Truth','Ensemble','Location','south')     

DOY=1:7:243;     
%plot Z_means at 5 locations
figure(5);hold on
plot(DOY,ZMEAS(1,:),'or','Linewidth',2);
figure(6);hold on
plot(DOY,ZMEAS(2,:),'ob','Linewidth',2);
figure(7);hold on
plot(DOY,ZMEAS(3,:),'oc','Linewidth',2);
figure(8);hold on
plot(DOY,ZMEAS(4,:),'og','Linewidth',2);
figure(9);hold on
plot(DOY,ZMEAS(5,:),'om','Linewidth',2);
%plot truth SD at 5 locations
    figure(5);hold on
    plot(DOY,squeeze(states.maps.SD(19,3,24:168:5808)),'k','Linewidth',1.5);
    figure(6);hold on
    plot(DOY,squeeze(states.maps.SD(15,8,24:168:5808)),'k','Linewidth',1.5);
    figure(7);hold on
    plot(DOY,squeeze(states.maps.SD(8,10,24:168:5808)),'k','Linewidth',1.5);
    figure(8);hold on
    plot(DOY,squeeze(states.maps.SD(12,16,24:168:5808)),'k','Linewidth',1.5);
    figure(9);hold on
    plot(DOY,squeeze(states.maps.SD(14,17,24:168:5808)),'k','Linewidth',1.5);
    %plot open loop ensemble at 5 locations
for i=1:20
    figure(5);hold on
    plot(DOY,squeeze(olmapSD.mapSD(19,3,24:168:5808,i)),'--r');
    figure(6);hold on
    plot(DOY,squeeze(olmapSD.mapSD(15,8,24:168:5808,i)),'--b');
    figure(7);hold on
    plot(DOY,squeeze(olmapSD.mapSD(8,10,24:168:5808,i)),'--c');
    figure(8);hold on
    plot(DOY,squeeze(olmapSD.mapSD(12,16,24:168:5808,i)),'--g');
    figure(9);hold on
    plot(DOY,squeeze(olmapSD.mapSD(14,17,24:168:5808,i)),'--m');
end
    figure(5);hold on
    xlabel('DOWY');ylabel('SD (m)')
    set(gca,'FontSize',18,'YDir','normal');grid;
    legend('Meas (19,3)','Truth','Ensemble','Location','northeast')
    figure(6);hold on
    xlabel('DOWY');ylabel('SD (m)')
    set(gca,'FontSize',18,'YDir','normal');grid;
    legend('Meas (15,8)','Truth','Ensemble','Location','northeast')
    figure(7);hold on
    xlabel('DOWY');ylabel('SD (m)')
    set(gca,'FontSize',18,'YDir','normal');grid;
    legend('Meas (8,10)','Truth','Ensemble','Location','northeast')
    figure(8);hold on
    xlabel('DOWY');ylabel('SD (m)')
    set(gca,'FontSize',18,'YDir','normal');grid;
    legend('Meas (12,16)','Truth','Ensemble','Location','northeast')
    figure(9);hold on
    xlabel('DOWY');ylabel('SD (m)')
    set(gca,'FontSize',18,'YDir','normal');grid;
    legend('Meas (14,17)','Truth','Ensemble','Location','northeast')
    cd('C:\Users\BANZH\Downloads\2019spring\CEE Steve\Project_outputs\long_true_output_weekly_0.1\');
    mkdir('C:\Users\BANZH\Downloads\2019spring\CEE Steve\Project_outputs\long_true_output_weekly_0.1\Figures');
    saveas(figure(1),[pwd '/Figures/basin_avg_SD.png']);        
    saveas(figure(2),[pwd '/Figures/basin_avg_Srz.png']);        
    saveas(figure(3),[pwd '/Figures/basin_avg_ET.png']);     
    saveas(figure(4),[pwd '/Figures/basin_avg_Q.png']);        
    saveas(figure(5),[pwd '/Figures/compMeas1.png']);
    saveas(figure(6),[pwd '/Figures/compMeas2.png']);
    saveas(figure(7),[pwd '/Figures/compMeas3.png']);
    saveas(figure(8),[pwd '/Figures/compMeas4.png']);
    saveas(figure(9),[pwd '/Figures/compMeas5.png']);
    pause
    close(figure(1));
    close(figure(2));
    close(figure(3)); 
    close(figure(4));
    close(figure(5));
    close(figure(6));
    close(figure(7));
    close(figure(8));
    close(figure(9)); 